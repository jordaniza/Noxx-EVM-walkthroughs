# Call and Delegatecall

`CALL` and `DELEGATECALL` execute functions with different execution contexts, specifically:

- `CALL` loads a call destination (function signature), along with function arguments
- `DELEGATECALL` is the same as call executes the *code* of another contract call, using the *data* in the current contract



## Delegatecall

```js
contract Base {
    string str = "Base";

    function sayHello() external view returns (string memory) {
        return string.concat(str, " Hello");
    }
}

contract Delegate {
    string str = "Delegate";

    function delegateHello(address _base) external returns (string memory) {
        (bool success, bytes memory data) = _base.delegatecall(
            abi.encodeWithSelector(Base.sayHello.selector)
        );
        require(success, "Call failed");
        return string(data);
    }
}

contract RunDelegate is Script {
    function run() public {
        Base base = new Base();
        Delegate delegate = new Delegate();

        console.log(base.sayHello());
        console.log(delegate.delegateHello(address(base)));
    }
}
```

Run the above code with `forge script RunDelegate`:

```
== Logs ==
Base Hello
Delegate Hello
```

So, in principle, `DELEGATECALL` is fairly simple. It has some VERY big gotchas and sharp edges though.

## Slot Ordering in delegatecall

> Major takeaway: **The EVM only cares about storage slot ordering when using DELEGATECALL**

State variables are not indexed in the same way functions are (noting that *public* variables are syntatic sugar for state variables with autogenerated getter functons). So:

```js
contract X {
    uint8 _x = 0x01;
    function x() public view returns (uint8) {
        return _x;
    }
}

// is the same as:
contract X {
    uint8 public x = 0x01;
}
```

This is important because it highlights that the function signature for x() will address to the correct function, but *the evm doesn't do any sort of unique indexing for state*.

Instead, when we `DELEGATECALL`, the EVM will just read from the corresponding storage slot in the orginating contract:

```js
contract StorageSlotCollisionBase {
    bool public isAuthorized = false;

    function checkIsAuth() external view returns (bool) {
        return isAuthorized;
    }
}

// isAuthorized is not sourced by name. It is sourced by storage slot.
// boolean coercing of 1 == true, your auth check is now broken
contract StorageSlotCollisionRekt {
    uint256 slot0 = 1;
    bool public isAuthorized = false;

    function delegateAuth(address _base) external returns (bytes memory, bool) {
        (bool success, bytes memory data) = _base.delegatecall(abi.encodeWithSelector(StorageSlotCollisionBase.checkIsAuth.selector));
        require(success, "Call failed");
        return (data, abi.decode(data, (bool)));
    }
}
```

`slot0` is used instead of `isAuthorized` in the delegatecall, when converting to boolean, this will return `true` instead of `false` - this was the cause of the Audius exploit not too long ago.

Instead, you need to make sure you're calling delegate call directly

> Warning: Obviously don't write a contract that accepts any address and delegatecalls it for auth, this is just an example.

```js
// correct use of delegate call respects the storage slot ordering
// this is the basis of upgradeable smart contracts
contract StorageSlotCollisionBigBrain {
    bool public isAuthorized = false;
    uint256 slot1 = 1;

    function delegateAuth(address _base) external returns (bytes memory, bool) {
        (bool success, bytes memory data) = _base.delegatecall(abi.encodeWithSelector(StorageSlotCollisionBase.checkIsAuth.selector));
        require(success, "Call failed");
        return (data, abi.decode(data, (bool)));
    }
}
```

There's a test for one of the ethernaught challenges in this repo that shows another risk of having delegatecall.

## Opcode View

`CALL` and `DELEGATECALL` are fancy Opcodes, they have a number of params:

> Sub Context is the target contract in delegatecall

- gas - for the remote execution
- addr - address to call/delegatecall
- argsOffset - byte offset in memory (current context), will be the calldata of the sub-context
- argsLength - bytesize to copy (size of calldata)
- retOffset - where in current memory to store return data
- retLength	- byte size in current memory to write 
- value (`CALL` only) - any wei to send

Note:
> "Delegate call doesnâ€™t require a value input as it is inherited from its parent call. Recall when we mentioned that the execution context has the same storage, msg.sender & msg.value as its parent call."

Another fun caveat: the True/False return value of `DELEGATECALL` **will return `TRUE` if called on an EOA** - watch out for that if using the return value as a check.