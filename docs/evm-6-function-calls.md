# Calling Functions

Recall that contracts are compiled to bytecode and stored on chain:

For example, the [Disperse App](https://etherscan.io/address/0xD152f549545093347A162Dce210e7293f1452150#code):

```
608060405234801561001057600080fd5b506106f480610...70ca5d3b491e160029
```

This can be switched to a series of Opcodes as we have seen. The Opcodes contain stack manipulations and JUMPs, specifically:

[Source](https://www.evm.codes/#56?fork=grayGlacier)

- JUMP 56
- JUMPI 57
- JUMPDEST 5b


CTRL+F `57` and `5b` below to see that we have pairings of JUMPDEST and JUMP, which [usually indicate a function](https://ethereum.stackexchange.com/questions/78357/map-bytecode-of-function-to-function-within-entire-bytecode)

In the file `'./ABI.json` we have the following function:

```json
  {
    "constant": false,
    "inputs": [
      { "name": "token", "type": "address" },
      { "name": "recipients", "type": "address[]" },
      { "name": "values", "type": "uint256[]" }
    ],
    "name": "disperseTokenSimple",
    "outputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  }
```

We can grab the hash by putting the following value into a [keccak hash utiility](https://emn178.github.io/online-tools/keccak_256.html):

`disperseTokenSimple(address,address[],uint256[])` = `51ba162c`

Search the full bytecode below:

```
608060405234801561001057600080fd5b506106f4806100206000396000f300608060405260043610610057576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806351ba162c1461005c578063c73a2d60146100cf578063e63d38ed14610142575b600080fd5b34801561006857600080fd5b506100cd600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390505050610188565b005b3480156100db57600080fd5b50610140600480360381019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001908201803590602001919091929391929390803590602001908201803590602001919091929391929390505050610309565b005b6101866004803603810190808035906020019082018035906020019190919293919293908035906020019082018035906020019190919293919293905050506105b0565b005b60008090505b84849050811015610301578573ffffffffffffffffffffffffffffffffffffffff166323b872dd3387878581811015156101c457fe5b9050602002013573ffffffffffffffffffffffffffffffffffffffff1686868681811015156101ef57fe5b905060200201356040518463ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019350505050602060405180830381600087803b1580156102ae57600080fd5b505af11580156102c2573d6000803e3d6000fd5b505050506040513d60208110156102d857600080fd5b810190808051906020019092919050505015156102f457600080fd5b808060010191505061018e565b505050505050565b60008060009150600090505b8585905081101561034657838382818110151561032e57fe5b90506020020135820191508080600101915050610315565b8673ffffffffffffffffffffffffffffffffffffffff166323b872dd3330856040518463ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019350505050602060405180830381600087803b15801561041d57600080fd5b505af1158015610431573d6000803e3d6000fd5b505050506040513d602081101561044757600080fd5b8101908080519060200190929190505050151561046357600080fd5b600090505b858590508110156105a7578673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb878784818110151561049d57fe5b9050602002013573ffffffffffffffffffffffffffffffffffffffff1686868581811015156104c857fe5b905060200201356040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b15801561055457600080fd5b505af1158015610568573d6000803e3d6000fd5b505050506040513d602081101561057e57600080fd5b8101908080519060200190929190505050151561059a57600080fd5b8080600101915050610468565b50505050505050565b600080600091505b858590508210156106555785858381811015156105d157fe5b9050602002013573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc858585818110151561061557fe5b905060200201359081150290604051600060405180830381858888f19350505050158015610647573d6000803e3d6000fd5b5081806001019250506105b8565b3073ffffffffffffffffffffffffffffffffffffffff1631905060008111156106c0573373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501580156106be573d6000803e3d6000fd5b505b5050505050505600a165627a7a72305820104eaf57909eb0d29f37ba9e3196e8e88438f83546136cf61270ca5d3b491e160029
```

## How does the EVM call a function

When we execute a function call, the contract executes the runtime bytecode, passing the contract signature as calldata. In the case of a CALL opcode, we also copy the call data arguments into memory. Typically a function is translated into a set of Opcodes, bounded by JUMPDEST <-> JUMP, indicating the start and end of a function. 

We can see all contract signatures already exist in the runtime bytecode, so what this creates is a Jump Table: passing the signature will allow us to do conditional checks, so that we skip functions we don't want to call, and instead jump to the function that we DO want to call.